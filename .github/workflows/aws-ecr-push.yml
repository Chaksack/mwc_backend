name: Build and Push to AWS ECR

on:
  push:
    branches: [ staging ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: ${{ secrets.ECR || 'mwc-backend' }}
  IMAGE_TAG: latest
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
  ECS_CLUSTER: mwc-cluster
  ECS_SERVICE: mwc-backend-service
  ECS_TASK_DEFINITION: mwc-backend
  CONTAINER_NAME: mwc-backend

jobs:
  build-and-push:
    name: Build and Push to ECR
    runs-on: ubuntu-latest

    # Set environment based on trigger
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    # Set up Docker Buildx for faster builds with caching
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Create ECR repository if it doesn't exist
      run: |
        # Check if repository exists
        if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} 2>/dev/null; then
          echo "Repository ${{ env.ECR_REPOSITORY }} does not exist. Creating it..."
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }}
        else
          echo "Repository ${{ env.ECR_REPOSITORY }} already exists."
        fi

    # Cache Docker layers to speed up builds
    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    # Log environment information
    - name: Log environment information
      run: |
        echo "Preparing to build for ${{ env.ENVIRONMENT }} environment"
        echo "Using environment-specific configuration from GitHub Secrets"

    - name: Build and tag image for Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # Set environment-specific tag
        ENV_TAG=${{ env.ENVIRONMENT }}

        echo "Building Docker image for $ENV_TAG environment..."

        # Build the Docker image with caching and environment-specific args
        docker buildx build \
          --cache-from=type=local,src=/tmp/.buildx-cache \
          --cache-to=type=local,dest=/tmp/.buildx-cache-new \
          --build-arg DATABASE_URL=${{ secrets.DATABASE_URL }} \
          --build-arg RABBITMQ_URL=${{ secrets.RABBITMQ_URL }} \
          --build-arg RABBITMQ_USE_TLS=true \
          --build-arg JWT_SECRET=${{ secrets.JWT_SECRET }} \
          --build-arg SMTP_HOST=${{ secrets.SMTP_HOST }} \
          --build-arg SMTP_PORT=${{ secrets.SMTP_PORT }} \
          --build-arg SMTP_USER=${{ secrets.SMTP_USER }} \
          --build-arg SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }} \
          --build-arg EMAIL_FROM="${{ secrets.EMAIL_FROM }}" \
          --build-arg STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }} \
          --build-arg STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }} \
          --build-arg STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }} \
          --build-arg STRIPE_MONTHLY_PRICE_ID=${{ secrets.STRIPE_MONTHLY_PRICE_ID }} \
          --build-arg STRIPE_ANNUAL_PRICE_ID=${{ secrets.STRIPE_ANNUAL_PRICE_ID }} \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:$ENV_TAG \
          --load \
          --file Dockerfile \
          .

        # Output the image URI for use in subsequent steps or jobs
        echo "::set-output name=image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

        # Push the Docker image to ECR with multiple tags
        echo "Pushing Docker image to ECR with tags: $IMAGE_TAG, latest, and $ENV_TAG"
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$ENV_TAG

        echo "Successfully pushed image to ECR with tags: $IMAGE_TAG, latest, and $ENV_TAG"
  test-container-functionality:
    name: Test Container Functionality
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Test container functionality
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          echo "Testing container functionality..."

          # Pull the image from ECR
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}

          # Run the container with a unique name
          CONTAINER_NAME="test-container-${{ github.run_id }}"
          docker run -d --name $CONTAINER_NAME -p 8080:8080 \
            -e DATABASE_URL=${{ secrets.DATABASE_URL }} \
            -e RABBITMQ_URL=${{ secrets.RABBITMQ_URL }} \
            -e RABBITMQ_USE_TLS=true \
            -e JWT_SECRET=${{ secrets.JWT_SECRET }} \
            -e SMTP_HOST=${{ secrets.SMTP_HOST }} \
            -e SMTP_PORT=${{ secrets.SMTP_PORT }} \
            -e SMTP_USER=${{ secrets.SMTP_USER }} \
            -e SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }} \
            -e EMAIL_FROM="${{ secrets.EMAIL_FROM }}" \
            -e STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }} \
            -e STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }} \
            -e STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }} \
            -e STRIPE_MONTHLY_PRICE_ID=${{ secrets.STRIPE_MONTHLY_PRICE_ID }} \
            -e STRIPE_ANNUAL_PRICE_ID=${{ secrets.STRIPE_ANNUAL_PRICE_ID }} \
            $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}

          # Wait for container to start
          echo "Waiting for container to start..."
          sleep 10

          # Check if container is running
          if [ "$(docker inspect -f {{.State.Running}} $CONTAINER_NAME)" = "true" ]; then
            echo "✅ Container is running successfully"
          else
            echo "❌ Container failed to start"
            docker logs $CONTAINER_NAME
            exit 1
          fi

          # Check container logs for errors
          echo "Checking container logs..."
          if docker logs $CONTAINER_NAME | grep -i "error\|exception\|fatal"; then
            echo "❌ Found errors in container logs"
            docker logs $CONTAINER_NAME
            exit 1
          else
            echo "✅ No errors found in container logs"
          fi

          # Install necessary tools for testing
          echo "Installing necessary tools for testing..."
          docker exec $CONTAINER_NAME apk add --no-cache curl net-tools 2>/dev/null || true

          # Check if database migration and AmazonMQ connection were successful
          echo "Checking if database migration and AmazonMQ connection were successful..."
          if docker logs $CONTAINER_NAME | grep -q "Database migration completed." && docker logs $CONTAINER_NAME | grep -q "RabbitMQ/Amazon MQ connected successfully."; then
            echo "✅ Database migration and AmazonMQ connection successful"
          else
            echo "❌ Database migration or AmazonMQ connection failed"
            docker logs $CONTAINER_NAME
            exit 1
          fi

          # Check if the container is listening on port 8080 (warning only, not failing the test)
          echo "Checking if container is listening on port 8080..."
          if docker exec $CONTAINER_NAME netstat -tuln | grep -q ":8080"; then
            echo "✅ Container is listening on port 8080"
          else
            echo "⚠️ Container is not listening on port 8080, but database migration and AmazonMQ connection were successful"
            docker logs $CONTAINER_NAME | grep -E "PORT|port|listen|binding"
          fi

          # Try to make a request to the application (warning only if port 8080 is not available)
          echo "Testing application responsiveness..."

          # Check if port 8080 is available before attempting HTTP request
          if docker exec $CONTAINER_NAME netstat -tuln | grep -q ":8080"; then
            # Try to connect to the root endpoint
            HEALTH_CHECK_RESULT=$(docker exec $CONTAINER_NAME curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ || echo "Failed to connect")

            if [[ $HEALTH_CHECK_RESULT == "Failed to connect" ]]; then
              echo "⚠️ Health check failed - could not connect to application, but database migration and AmazonMQ connection were successful"
            elif [[ $HEALTH_CHECK_RESULT -ge 200 && $HEALTH_CHECK_RESULT -lt 500 ]]; then
              echo "✅ Successfully connected to application"
              echo "HTTP status code: $HEALTH_CHECK_RESULT"
            else
              echo "⚠️ Application returned error status code: $HEALTH_CHECK_RESULT, but database migration and AmazonMQ connection were successful"
            fi
          else
            echo "⚠️ Skipping HTTP request test as port 8080 is not available, but database migration and AmazonMQ connection were successful"
          fi

          # Clean up
          docker stop $CONTAINER_NAME
          docker rm $CONTAINER_NAME

          echo "✅ Container test completed successfully"

  send-slack-test-notification:
    name: Send Slack Test Notification
    runs-on: ubuntu-latest
    needs: test-container-functionality
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Send Slack notification - Test Success
        if: success()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: deployments
          SLACK_COLOR: good
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: |
            ✅ Container tests passed successfully for ${{ env.ENVIRONMENT }} environment
            *Image:* ${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
            *Required tests passed:*
            - Container startup
            - Database migration successful
            - AmazonMQ connection successful
            *Optional tests (warnings only):*
            - Port availability (8080)
            - HTTP endpoint responsiveness
            *Commit:* ${{ github.sha }}
            *Pushed by:* ${{ github.actor }}
          SLACK_TITLE: Container Tests Success
          SLACK_USERNAME: GitHub Actions

      # Send Slack notification for test failure
      - name: Send Slack notification - Test Failure
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: deployments
          SLACK_COLOR: danger
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: |
            ❌ Container tests failed for ${{ env.ENVIRONMENT }} environment
            *Image:* ${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
            *Possible issues:*
            - Container failed to start
            - Errors in container logs
            - Database migration failed
            - AmazonMQ connection failed
            *Commit:* ${{ github.sha }}
            *Pushed by:* ${{ github.actor }}
            *Check the [GitHub Actions logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details*
          SLACK_TITLE: Container Tests Failure
          SLACK_USERNAME: GitHub Actions
  send-deployment-notification:
    name: Send Deployment Notification
    runs-on: ubuntu-latest
    needs: test-container-functionality
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Deployment Summary
        run: |
          echo "✅ Deployment Summary"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
          echo "Commit: ${{ github.sha }}"
          echo "Pushed by: ${{ github.actor }}"

      # Send Slack notification for successful deployment
      - name: Send Slack notification - Success
        if: success()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: deployments
          SLACK_COLOR: good
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: |
            ✅ Successfully deployed to ${{ env.ENVIRONMENT }} environment
            *Image:* ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
            *Commit:* ${{ github.sha }}
            *Pushed by:* ${{ github.actor }}
          SLACK_TITLE: Deployment Success
          SLACK_USERNAME: GitHub Actions

      # Send Slack notification for failed deployment
      - name: Send Slack notification - Failure
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: deployments
          SLACK_COLOR: danger
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: |
            ❌ Failed to deploy to ${{ env.ENVIRONMENT }} environment
            *Repository:* ${{ github.repository }}
            *Commit:* ${{ github.sha }}
            *Workflow:* ${{ github.workflow }}
            *Pushed by:* ${{ github.actor }}
            *Check the [GitHub Actions logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details*
          SLACK_TITLE: Deployment Failure
          SLACK_USERNAME: GitHub Actions

  deploy-to-ecs:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: build-and-push

    # Set environment based on trigger
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || 'staging' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Get AWS account ID
        id: get-aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "::set-output name=aws_account_id::$AWS_ACCOUNT_ID"

      - name: Prepare task definition
        run: |
          # Replace placeholders in task definition
          sed -i "s/ACCOUNT_ID/${{ steps.get-aws-account.outputs.aws_account_id }}/g" task-definition.json

      - name: Replace environment variables with GitHub secrets
        run: |
          # Create a temporary file with environment variables
          cat > env-values.json << EOF
          {
            "DATABASE_URL": "${{ secrets.DATABASE_URL }}",
            "RABBITMQ_URL": "${{ secrets.RABBITMQ_URL }}",
            "JWT_SECRET": "${{ secrets.JWT_SECRET }}",
            "SMTP_HOST": "${{ secrets.SMTP_HOST }}",
            "SMTP_PORT": "${{ secrets.SMTP_PORT }}",
            "SMTP_USER": "${{ secrets.SMTP_USER }}",
            "SMTP_PASSWORD": "${{ secrets.SMTP_PASSWORD }}",
            "EMAIL_FROM": "${{ secrets.EMAIL_FROM }}",
            "STRIPE_SECRET_KEY": "${{ secrets.STRIPE_SECRET_KEY }}",
            "STRIPE_PUBLISHABLE_KEY": "${{ secrets.STRIPE_PUBLISHABLE_KEY }}",
            "STRIPE_WEBHOOK_SECRET": "${{ secrets.STRIPE_WEBHOOK_SECRET }}",
            "STRIPE_MONTHLY_PRICE_ID": "${{ secrets.STRIPE_MONTHLY_PRICE_ID }}",
            "STRIPE_ANNUAL_PRICE_ID": "${{ secrets.STRIPE_ANNUAL_PRICE_ID }}"
          }
          EOF

          # Use jq to update the task definition
          jq --slurpfile env env-values.json '
            .containerDefinitions[0].environment |= map(
              if .value | endswith("_PLACEHOLDER") then
                $key = .name;
                $placeholder = .value;
                $value = $env[0][$key];
                .value = $value
              else
                .
              end
            )
          ' task-definition.json > task-definition-updated.json

          # Replace the original file
          mv task-definition-updated.json task-definition.json

          # Clean up
          rm env-values.json

      - name: Update container image
        id: update-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.ENVIRONMENT }}
          AWS_ACCOUNT_ID: ${{ steps.get-aws-account.outputs.aws_account_id }}
        run: |
          # Update the image in the task definition
          NEW_IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          sed -i "s|$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/$ECR_REPOSITORY:[^ \"]*|$NEW_IMAGE|g" task-definition.json
          echo "::set-output name=image::$NEW_IMAGE"

      - name: Register new task definition
        id: register-task
        run: |
          NEW_TASK_DEF=$(aws ecs register-task-definition --cli-input-json file://task-definition.json)
          NEW_REVISION=$(echo $NEW_TASK_DEF | jq -r '.taskDefinition.revision')
          echo "::set-output name=revision::$NEW_REVISION"

      - name: Deploy to ECS
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.ECS_TASK_DEFINITION }}:${{ steps.register-task.outputs.revision }} \
            --force-new-deployment

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}

      - name: Deployment Summary
        run: |
          echo "✅ ECS Deployment Summary"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Cluster: ${{ env.ECS_CLUSTER }}"
          echo "Service: ${{ env.ECS_SERVICE }}"
          echo "Task Definition: ${{ env.ECS_TASK_DEFINITION }}:${{ steps.register-task.outputs.revision }}"
          echo "Image: ${{ steps.update-image.outputs.image }}"

      # Send Slack notification for successful deployment
      - id: send-ecs-deployment-notification
        name: Send Slack notification - Success
        if: success()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: deployments
          SLACK_COLOR: good
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: |
            ✅ Successfully deployed to ECS in ${{ env.ENVIRONMENT }} environment
            *Cluster:* ${{ env.ECS_CLUSTER }}
            *Service:* ${{ env.ECS_SERVICE }}
            *Task Definition:* ${{ env.ECS_TASK_DEFINITION }}:${{ steps.register-task.outputs.revision }}
            *Image:* ${{ steps.update-image.outputs.image }}
          SLACK_TITLE: ECS Deployment Success
          SLACK_USERNAME: GitHub Actions

      # Send Slack notification for failed deployment
      - name: Send Slack notification - Failure
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: deployments
          SLACK_COLOR: danger
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: |
            ❌ Failed to deploy to ECS in ${{ env.ENVIRONMENT }} environment
            *Repository:* ${{ github.repository }}
            *Workflow:* ${{ github.workflow }}
            *Check the [GitHub Actions logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details*
          SLACK_TITLE: ECS Deployment Failure
          SLACK_USERNAME: GitHub Actions
